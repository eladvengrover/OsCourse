void* dequeue(void) {
    Item *dequeued_item;
    void *returned_value;
    mtx_lock(&queue->mutex);
    while (queue->size == 0) {
        atomic_fetch_add(&waiting_threads, 1);
        cnd_wait(&queue->queue_not_empty, &queue->mutex);
        atomic_fetch_sub(&waiting_threads, 1);
    }
    printf("---- DEQUEUE ----\n");
    dequeued_item = queue->first;
    returned_value = dequeued_item->value;
    printf("old first: %d, old last: %d, old size: %d\n", *((int *)queue->first->value), *((int *)queue->last->value), queue->size);
    printf("Dequeuing item %d\n", *((int *)returned_value));
    if (queue->size == 1) {
        queue->first = NULL;
    } else {
        queue->first = queue->first->next;
    }
    queue->size--;
    printf("new first: %d, new size: %d\n", *((int *)queue->first->value), queue->size);
    free(dequeued_item);
    atomic_fetch_add(&visited_items, 1);
    cnd_signal(&queue->queue_not_empty);
    mtx_unlock(&queue->mutex);
    return returned_value;
}